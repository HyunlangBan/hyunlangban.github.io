---
layout: post
tag: fullstack
title: SQLAlchemy ORM in Depth
---
### Overview
- SQLAlchemy와 SQLAlchemy ORM은 파이썬 환경에서 모델을 만들거나 상호작용하기 위해 사용하는 가장 인기있는 라이브러리 중 하나이다.
- It's a very well-developed library that offers flexibility and versatility(ability to adapt or be adapted to many different functions or activities) and how we can work with models in our web applications.

### Model.**query**
- Query는 SQLAlchemy에서 생성되는 모든 `SELECT`문의 근원지이다.
- SQLAlchemy application에서 정의했던 model에 존재하는 object이다.

#### 다양한 쿼리 메소드들
- `Person.query.filter_by(name='Amy)`
   - `SELECT * FROM Person WHERE name = 'Amy';`과 동일
- `Person.query.all()`
  - `SELECT * FROM Person;`
- `Person.query.count()`
  - SQL에서의 Group by count와 동일
- `Person.query.filter(Person.name == 'Amy')
  - `.filter_by()`보다 더 flexible한 방법
  - 모델의 attribute를 결정할 수 있다. 이것은 조인 모델에서 쿼리를 할 때 다양한 모델들 중에서 attribute를 골라서 필터를 할 수 있는 장점이 있다.
  - +)[common filter operators](https://docs.sqlalchemy.org/en/13/orm/tutorial.html#common-filter-operators)
- `Person.query.filter(Person.name == 'Amy', Tema.name == 'Udacity')
  - 모델의 attribute의 이름을 사용할 수도 있고 다른 테이블의 모델을 이용 할 수도 있다.
- `Person.query.get(1)`
  - 기본키(primary key)로 object를 얻는다.

#### Bulk operations
`Product.query.filter_by(category='Misc').delecte()`<br>
bulk operation이란 large scale로 수행되는 action들을 말한다.<br>
위의 코드는 카테고리가 'Misc'인 모든 레코드들을 한꺼번에 삭제한다.

#### Model.query method chaining
`query`의 메소드들은 `first()`나 `all()`, `count()`, `delete()`처럼 non-query object를 리턴하는 terminal method를 사용하기 전까지는 무한으로 계속 엮일 수 있다.<br>
 `Person.query.filter(Person.name == 'Amy').frist()`도 가능하고 `Person.query.filter(Person.name == 'Amy').flter(Tema.name == 'Udacity').first()`도 가능하다. SQL문에서 여러개의 WHERE절이 함께 쓰이는 것과 같은 의미이다.<br><br>
 
 method chaining은 join이나 join을 해야할때 필수적이다.<br>
 `Driver.query.join('vehicles').filter_by(driver_id=3).all()`는 Driver table과 vehicles table을 조인하고 driver_id=3인 레코드들을 리턴한다.<br><br>
**Question**. SQL에서는 조인할때 ON절이 필요하지만 여기서는 테이블 이름만 써준다. 그럼 얘네는 기준키를 어떻게 인식하는걸까?

#### 모델의 쿼리 오브젝트에 접근하는 두가지 방식
- `Person.query`
- `db.session.query(Person)`

The reason why we might want to do it this way instead of using an individual model is that every once in ah while you may want to do a joint query instead. --> `session.query(Person).join(Team)`<br>
So since `session.query` is [agnostic](http://egloos.zum.com/nemonein/v/5287050)(=>~와 관계없는, 종속적이지 않은) to the type of model that you pass in, you can do things like `session.query` of `person.join` on another model Team.<br>
--> 잘 이해가 안됨...
 
 +) [SQLALchemy Query API](https://docs.sqlalchemy.org/en/13/orm/query.html)

### Practice
Let's say you created a Users tale with a `name` attribute. 
1. Implement a query to filter all users by name 'Bob'.
```
User.query.filter_by(name='Bob').all()
```

2. Implement a LIKE query to filter the users for records with a name that includes the letter "b".
```
User.query.filter(User.name.like('%b%')).all()
```

3. Return only the first 5 records of the query above.
```
User.query.limit(5).all()
```

4. Re-implement the Like query using case-insesitive search.
```
User.query.filter(or_(User.name.like('%B%'), User.name.like('%b%'))).all()
```

5. Return the *number* of records of users with name 'Bob'.
```
User.query.filter_by(name='Bob').count()
```
