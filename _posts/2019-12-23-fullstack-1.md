---
layout: post
title: Interacting with Database
tag: fullstack
---


## Full-Stack 1
[Udacity의 Full-Stack Web Developer](https://www.udacity.com/course/full-stack-web-developer-nanodegree--nd0044) 강의를 듣고 정리합니다.
<br>
<br>
(( **혹시나 수강을 고민하시고 있는 분들을 위한 한가지 정보!** -> 위 강의를 누르면 카운트다운이 되는 게 보이면서 그 기간이 지나면 수강 신청을 할 수 없는 것처럼 보인다. 그거 때문에 불안해서 D-1일에 바로 결제했다. 근데 결제하고 보니 그 이후로 카운트다운이 리셋되고 그 이후에도 계속 신청할 수 있었다. 나는 12월에는 강의를 들을 시간이 많이 없었는데도 그거 때문에 무리해서 결제했는데 돈이 좀 아까웠다.

결제 방식이 두 가지가 있는데 한 가지는 한 번에 5달치(종강일까지)를 바로 결제하는 경우, 두 번째는 한 달씩 돈이 빠져나가는 경우다.

한 달마다 빠져나가는 걸로 하면 한 번에 결제했을 때의 한 달 가격보다 조금 더 비싸다. 하지만! 한 번에 5달을 결제하게 되면 장기간 못 듣게 되는 일이 생길 때 정지, 취소 불가다. 한 달만큼만 결제하면 한 달씩 돈이 자동으로 빠져나가고 취소하면 그 다음 달부터 빠져나가진 않는 것 같다. 그렇게 되면 자기가 못 듣게 되는 일이 생겼을 때 그 달 동안은 취소를 해두면 된다.

5달을 한 번에 결제한 경우에도 나중에 기간 내에 완수하지 못한 경우 한 달씩 연장이 가능한데 적은 돈이 아니기 때문에 수업을 듣는 기간이 유동적인 경우에는 한 달씩 결제하는 게 훨씬 낫고 빡세게 종강일까지 쭉 집중할 수 있는 경우라면 비교적 할인된 가격으로 한 번에 결제하는 것이 좋을 듯하다. ))

<br><br>
### Interacting with Database
---

### Exeuction Plan
The DBMS takes a SQL query and generates an execution plan for the database engine to follow.<br>
- 쿼리문을 작성하면 그 쿼리문이 어떤 순서로 어떻게 실행되는지 execution plan이 존재한다. execution plan을 살펴봄으로써 쿼리의 성능에 대한 중요한 통찰력을 가질 수 있다.

#### Join을 실행할 때 Execution Plan
```
SELECT make, model FROM vehicles
JOIN drivers ON vehicels.driver_id = drivers.id;
```

위와 같은 쿼리문을 작성했다면 어떤 방식으로 실행 될까?
먼저 [Hash Join](https://www.depesz.com/2013/05/09/explaining-the-unexplainable-part-3/#hash-join)을 알아야한다.
위와 같이 join문을 실행하게 되면 Hash JOIN이 실행된다.

해시 조인이라는 것은 해시테이블을 하나 만들고 그 해시 테이블과 다른 테이블을 비교하여 조인을 하는 것이다.
좀 더 자세히 말하자면 우리는 vehicles라는 테이블에서 driver_id 칼럼을 이용하여 조인을 진행할 것이다.
그럼 driver_id 칼럼을 기준으로 해시 테이블을 만든다. hash table의 key는 driver_id가 되는 것이고 key에 맞는 데이터의 row를 저장해준다.

Perl notation을 참고하니 이해가 더 쉬웠다.
```
'123` => [ {data for row with driver_ID = 123 }, ],
'256' => [ {data for row with driver_ID = 256 }. ],
...
```

이렇게 만들어진 해시 테이블을 이용해서 아까 지정해두었던 다른 테이블(drivers)과 조인할 수 있는지 확인한다.
drivers 테이블의 id 칼럼의 각 value들이 hash에 존재하는지 확인한다.(drivers의 한 열마다 해시 테이블은 매번 전체 탐색된다.)
만약 존재하면 hash에 해당하는 값이 조인되어 output rows를 만든다.

(근데 조인을 하는 두 테이블 중 어떤 테이블이 해시테이블로 사용되는지 참고 사이트마다 다 달라서 이부분은 더 조사를 해봐야겠다.)
<br>--> **update**: 쿼리를 어떻게 쓰느냐에따라 정해지는 것은 아니고 관계가 더 적은 테이블이 해시테이블로 만들어지는데 이는 프로그램 내부에서 자동으로 돌아가는 것이기 때문에 어떻게 관계가 결정되는지는 잘 모르겠다고 한다.

그냥 조건이 일치하면 테이블이 조인되는 줄 알았는데 어떤 절차로 이루어지는지 생각하진 못했었다. 한 페이지밖에 안되었지만 이해하는데 꽤 고생했다. 휴

<br><br>
### Client-Server Model
서버-클라이언트 모델에 데이터베이스가 추가된다면?
```
Web Client(다수 존재 가능) <--> Web Server <--> Database Server
```

#### Servers, Clients, Hosts
- 서버-클라이언트 모델에서 서버는 다수의 클라이언트에 대한 처리를 수행 할 수 있다.(레스토랑의 웨이터와 손님의 관계)
- 서버와 클라이언트는 호스트(Hosts)에서 실행되는 프로그램이다.
- **호스트(Hosts)란 네트워크에 연결된 컴퓨터**들을 말한다.(ex. 인터넷)

#### Request and Respones
- 클라이언트는 서버에 요청을 보낸다.
- 서버는 클라이언트에서 받은 요청을 수행하고 클라이언트에게 응답을 보낸다.
- **커뮤니케이션 프로토콜**을 통해 서버와 클라이언트가 소통할 수 있다.

#### Relational Database Clients
- 데이터베이스 클라이언트는 데이터베이스에 요청을 보내는 프로그램을 말한다.
- 어떨 때는 데이터베이스 클라이언트가 웹 서버이기도 하다. 만약 웹 브라우저가 요청을 보내면 웹 서버는 서버의 역할을 하지만 웹 서버가 데이터베이스에 요청을 보내게 된다면 웹서버는 클라이언트가 되고 데이터베이스는 서버이다.(상대적 개념)


#### Workflow
예시) 옷가게 사이트에서 어떤 상품(ex. Polo)를 클릭하면 상세페이지가 나오는 경우
- 클라이언트는 서버에게 요청 타입이나 입력 값을 포함한 요청을 보낸다. 예시에서는 polo의 아이디는 1로 설정하였다. 또한 Polo에 관한 detail에 관한 내용과 상세 페이지 view를 요청한다. 
- 서버는 요청을 받고 클라이언트에서 받아 온 값으로 데이터베이스에 보내는 요청을 어떻게 만들지 결정하는데에 사용한다. 예시에서는 id값을 데이터베이스로 보내 정보를 받아오는 데에 사용했다.
- 데이터베이스는 요청을 처리하고 웹 서버에 응답을 보낸다.(polo에 대한 추가정보)
- 서버는 데이터베이스로 응답을 받고 그것으로 템플릿을 결정한다. 또한 받은 데이터로 뷰 템플릿을 구성하는데에 이용한 후 그것을 클라이언트 브라우저에 보낸다.(polo detail에 관한 템플릿과 해당되는 내용이 결정됨)
- 클라이언트는 최종적으로 사용자가 볼 수 있도록 뷰를 나타내준다.
<br><br>

### TCP/IP
서버와 클라이언트가 정보를 주고받기 위해서는 통신 프로토콜이 필요하다고 앞서 배웠다. 통신 프로토콜의 모음인 TCP/IP는 인터넷을 통해 데이터를 전달할 때 사용된다. TCP/IP라고 불리는 이유는 연관된 주요 프로토콜이 TCP(Transmission Control Protocol)와 IP(Internet Protocol)이기 때문이다. TCP/IP는 기기들을 연결하여 인터넷을 통해 정보를 전달한다.

#### TCP/IP uses:
- IP addresses: IP주소는 인터넷 상에서 컴퓨터의 위치를 확인한다.(해당 컴퓨터를 찾아서 연결하기 위하여)
- Ports: 포트는 컴퓨터에서 데이터를 받아들이는 곳이며 포트 넘버에 따라 특정 연결이 발생한다. 포트는 공항의 여러 터미널과 같은 의미이다. 여러 비행기들이 동시에 착륙하고 그러한 비행기들을 추적하는 것과 같이 동일한 IP주소에서 여러 유형의 트래픽을 효과적으로 수신할 수 있도록 허용한다.
  - Port 80: HTTP 요청들에 사용되는 가장 기본적인 포트 번호이다. 클라이언트가 웹 서버에 요청을 하면 그 요청이 80번 포트를 통해 보내진다.
  - Port 5432: 대부분의 데이터베이스 시스템들에 사용되는 포트넘버이다.

<br>
즉, 클라이언트와 서버는 TCP/IP를 통해 정보를 주고받는데 TCP/IP는 IP address를 통해(편지를 보낼 때 보내는 주소와 받는 주소가 모두 필요한 것처럼) 서로의 기기를 확인하고 데이터에 맞는 Port를 통해 정보의 전달이 발생하는 것이다.

#### Connections and Sessions in TCP/IP
- TCP/IP는 연결 기반 프로토콜이다. 통신을 하기 위해서는 클라이언트와 서버간 연결이 먼저 이루어져야 한다.
- 지속적으로 연결이 되어있는지 닫혀있는지 확인하는게 중요한데 이는 연결이 많을 수록 성능 문제가 발생 할 확률이 높기 때문이다.
- 세션은 연결의 시작과 끝을 표시한 것이다. 데이터 베이스 세션 내에서 많은 트랜젝션들이 발생한다. 각 트랜젝션들은 데이터베이스에 변화를 일으킨다.

#### TCP vs UDP
- UDP Protocol: UDP는 TCP보다 훨씬 단순한 프로토콜이다. 네트워크 상의 호스트는 어떠한 연결의 필요 없이 데이터를 전송한다.
- TCP가 주택간에 도로를 만들어서 택배를 보내는 개념으로 생각한다면 UDP는 비둘기를 날려서 택배를 보내는 것이라고 생각하면 된다. 비둘기가 당장 어디를 향할지 모르고 길을 따라서 가다가 택배를 어디엔가 떨어트리거나 여정 중 문제를 만날수도 있다. 하지만 TCP를 이용할때 연결을 관리하는 것보다 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등)가 적다.
- 만약 신뢰성보다 속도가 더 중요하다면(작은 정보들을 빠르게 스트림해야한다면) UDP가 선호된다.
- 많은 실시간 스트리밍 어플리케이션들이 UDP를 이용하고 있다. UDP는 잃어버린 datagram(전송 데이터의 단위)들을 재전송할 필요가 없고 어떠한 커넥션을 생성할 필요도 없다. 따라서 TCP보다 지연이 적다. 
- TCP의 지속적인 연결은 더 신뢰성이 있지만 레이턴시가 존재한다.

### Transactions
Transactions are automic **units of work** for the database to perform as a whole.

- 관계형 데이터베이스는 transactional하다.
  - 데이터에 생기는 모든 변화는 트랜잭션 이라는 단위를 통해 이루어진다.
  - 트랜잭션에는 한개 이상의 변화가 수행될 수 있으며 사용자가 트랜잭션에 배열한 순서대로 진행된다.
  - 트랜잭션을 처리할 때는 작업 하나가 실패하면 단위 전체가 실패하는 것이고 모든 작업이 성공적으로 처리되었을 때 성공이다.
  - 트랜잭션은 데이터 베이스의 데이터를 변화시키는 하나 이상의 UPDATE, INSERT, DELETE 구문으로 이루어진다.(쿼리(SELECT, GROUP BY)나 데이터 스키마(ALTER TABLE)에는 관여하지 않는다.)
  - 이러한 변화의 묶음은 트랜잭션을 ***commit***함으로써 데이터베이스에 반영된다.
  - 만약 오류가 발생했다면 ***rollback***을 통해 트랜잭션(작업의 묶음)을 하기 전으로 되돌릴 수 있다. 한개의 작업에서 오류가 발생했더라도 전체 트랜잭션을 모두 되돌린다.
  
- 왜 트랜잭션에 작업들을 묶는 것일까?
  - 데이터 베이스 시스템이 실패할 수 있다.
  - 우리는 데이터 베이스가 항상 유효한 상태이길 원한다.
  - [데이터의 일관성을 유지하면서 안정적으로 데이터를 복구할 수 있다.](https://jerryjerryjerry.tistory.com/48)
