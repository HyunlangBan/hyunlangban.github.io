---
layout: post
title: Migrations
tag: fullstack
---
### Migrations
- 데이터 스키마들의 변경을 관리하는 것을 담당한다.
- 데이터베이스 스키마에 대한 실수가 발생핟나면 전체 앱이 다운될 수도 있다. 따라서 우리는 다음을 원한다.
  - 빠르게 변경사항을 rollback하기
  - 변화를 적용하기 전에 테스트해보기
- Migraion이란 데이터베이스 스키마에 대한 변경사항들을 추적하는 파일이다.
  - 우리의 스키마에 관한 **version control**을 제공한다.
- Migrations의 파일명은 중복되지 않는다.
- 보통 프로젝트 repo에 local files로서 저장된다.(e.g. a `migrations/` folder)
- 데이터베이스에 생긴 변경사항과 `migrations/` 폴더에 저장된 `migration files`는 1대1 맵핑된다.
- Our migrations files set up the tables for our databse.
- db에 생긴 모든 변경사항들은 우리의 repository안에 migration의 부분으로서 물리적으로 존재해야한다.

#### Upgrades and rollbacks
- 우리는 migrations을 적용함으로써 데이터베이스 스키마를 **upgrade** 할 수 있다.
- 우리는 migrations를 reverting함으로써 데이터베이스 스키마를 이전 버전으로 **roll back** 할 수 있다.

#### Migration Command Line Scripts
- migrate: 만들어진 변경사항에 대하여 migration 파일을 생성한다.
- upgrade: 아직 적용되지 않은 migrations를 적용한다.
- downgrade: 문제가 있는 적용된 migrations을 roll back한다.

#### Migration Library for Flask + SQLAlchemy
- **Flask-Migrate** is our library for migrating changes using SQLAlchemy. It uses a library called **Alembic** underneath the hood.
- Flask-Migrate is our migration manager for migrating SQLAlchemy-based database changes
- Flask-Script lets us run migration scripts we defined, from the terminal

#### Migrations이 일어나는 과정
- Migrations을 저장하기 위해 migration repository structure를 초기화한다.
- Flask-Migrate를 이용하여 migration script를 만든다.
- (Manually)Flask-Scrip를 이용하여 migration script를 실행한다.

<br>

### Why Use Migrations?
- migrations이 없다면...
  - 아주 사소한 변화가 발생해도 모든 테이블들을 다시 만들어야한다.
  - 우리가 삭제한 예전 데이터들을 잃는다.
- migration을 사용한다면...
  - SQLAlchemy 모델의 old version과 new version의 변화를 자동으로 감지한다.
  - Old, new 버전 간의 차이점에 관한 migration script를 만든다.
  - 기존의 테이블을 변경하기 위하여 fine-grain control을 제공한다.
- migrations 사용이 더 좋은 이유
  - 기존 스키마 구조를 유지하면서 우리가 수정해야되는 부분만 수정하면 된다.
  - 기존 데이터를 보유할 수 있다.
  - We isolate units of change in migration scripts that we can roll back to a safe db state.
  
<br>

### Flask-Migrate
#### 설치방법
커맨드창에서 `pip install Flask-Migrate`를 실행한다.

#### 실행방법
```python
# app.py

from flask_migrate import Migrate

migrate = Migrate(app, db)   # Falsk app, SQLAlchemy database와 연결
```

#### Creating the migrations directory structure using `flask db init`
- Create inital migrations directory structure
- 커맨드 창에서 `app.py`이 저장된 폴더로 이동한 후 `falsk db init`을 해준다.
- 생성된 `alembic.ini`는 로깅, 파일 이름, 기본 포멧등의 구성을 설정할 수 있는 config scripts 이다.

#### Syncing models using `flask db migrate`
- 변경 사항을 감지하고 upgrade와 downgrade이 있는 migration 파일을 생성한다.
- 만약 우리가 `todos`를 저장했던 데이터베이스 `todoapp`을 삭제하고 다시 생성한 후 `flask db migrate`를 한다면 `versions` 폴더에 다음과 같은 migration이 생성된다.

```
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0647a25940c5'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('todos',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('description', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('todos')
    # ### end Alembic commands ###
```

#### `Flask db upgrade` and `flask db downgrade`
`todoapp`이라는 데이터베이스를 삭제했다가 다시 생성하면 안에 있던 테이블들을 다 사라진다.
하지만 `flask db upgrade`를 한 후 `todoapp` 내에 있는 테이블을 확인해보면 

```
todoapp=# \dt
           릴레이션(relation) 목록
 스키마 |      이름       |  종류  |  소유주
--------+-----------------+--------+----------
 public | alembic_version | 테이블 | postgres
 public | todos           | 테이블 | postgres
 ```
 
이와 같이 `todos`가 다시 생성된 것을 볼 수 있다. 생성된 내용은 migration에 있는 `upgrade()` 내용과 같다.
`alembic_version`이라는 테이블은 우리의 데이터베이스의 버전을 저장하고 migrations을 관리한다.
